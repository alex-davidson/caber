# Design: File System Listeners and Events

* Up: [Storage and File System](Design.FileSystem.md)
* Related: [Routing](Design.Routing.md)

When a route subscribes to a storage hierarchy, we need to detect changes in
order to dispatch them via the sender.

Polling a directory hierarchy for changes is inelegant and may be impractical
if it is large. Grafts complicate things further because we are then dealing
with many hierarchies. Furthermore we expect only a minority of files to be
updated in a given day.

We would prefer to have the operating system notify us when files change.

There are three representations of file paths:
* Raw OS path. This is what we'll get from the OS's filesystem event APIs.
* QualifiedPath. This is our internal canonical representation of a file
  within a LocalRoot.
* AbstractPath. This uniquely identifies a path in Caber's own virtual
  filesystem, exposed to other instances. Files which are excluded by filters
  do not have an AbstractPath.

The conversion from raw OS path to QualifiedPath involves doing casing
canonicalisation, therefore it is potentially expensive. Going from
QualifiedPath to AbstractPath is relatively cheap but not free, depending on
configuration complexity.

Filesystem events may be raised very rapidly if log messages are being written
individually to a file. .NET's FileSystemWatcher may drop events if its
internal buffer overflows, eg. because we're not handling events fast enough.

We need to throttle duplicates and maintain decent throughput.

## Events

We are primarily interested in events which logically add data to our abstract
filesystem. This means the following in FileSystemWatcher terms:
* Create: new files.
* Change: alterations to content of existing files.
* Rename: new file paths.

We don't care about deletions, since our abstract filesystem is append-only.
Similarly we don't care about the old path from a Rename event, only the new
path.

All important events have exactly two fields:
* Full OS path of the file.
* Timestamp of the event.

In the majority of cases we will not be seeing more than a few dozen events
per second, and can afford to be more intelligent about throttling, etc. But
in the cases where we cannot afford this I would rather not have the service
fail.

## Event Streams and Reactive Programming

.NET's Rx library is the usual way of handling event streams, but:
* the design seems to be extremely abstract,
* it is not obvious what's going on, especially in a profiler,
* I do not trust 'magic' in core library code, and
* I don't have time to read and comprehend all of the source.

Therefore I will not be using Rx.

## Event Pools

We can deal with events in layers:
1. Watcher event handlers will add file paths to a HashSet, then return
   immediately. These HashSets could be per Watcher to eliminate the need to
   synchronise access in the common case.
2. A periodic task (every 5 seconds?) will swap in new HashSets and add the
   previous sets' contents to a pool. This will require synchronisation.
3. A worker thread will process the contents of that pool, pushing timestamped
   events into a deduplicated queue, ie. one which ignores attempts to enqueue
   an item which is already present. The timestamps can be generated by this
   worker at the time it queues them, since deduplication has already taken
   place and precision of these timestamps will not be important.
4. That queue can then be processed by another worker, which resolves paths to
   QualifiedPaths, filters AbstractPaths, and does other heavyweight
   operations.

This gives us a stream of notifications of changes to
`{QualifiedPath,AbstractPath}` pairs, which can then be fed into the core
routing logic.

It is also trivial to unit test.

We don't really need to handle vast numbers of events with the initial implementation, but this does suggest how to structure component APIs:
* The watchers are responsible for pushing sets of paths into a shared pool. This may be triggered by a public method call.



